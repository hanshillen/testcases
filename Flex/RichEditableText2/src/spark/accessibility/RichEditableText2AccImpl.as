package spark.accessibility
{
	import flash.accessibility.Accessibility;
	import flash.events.Event;
	import flash.events.FocusEvent;
	import flash.text.engine.GraphicElement;
	import flash.utils.clearInterval;
	import flash.utils.clearTimeout;
	import flash.utils.setInterval;
	import flash.utils.setTimeout;
	
	import flashx.textLayout.compose.TextFlowLine;
	import flashx.textLayout.edit.ISelectionManager;
	import flashx.textLayout.elements.FlowElement;
	import flashx.textLayout.elements.LinkElement;
	import flashx.textLayout.events.FlowElementMouseEvent;
	import flashx.textLayout.events.SelectionEvent;
	import flashx.textLayout.tlf_internal;
	
	import mx.accessibility.AccConst;
	import mx.core.UIComponent;
	import mx.core.mx_internal;
	import mx.events.FlexEvent;
	import mx.utils.StringUtil;
	
	import spark.accessibility.RichEditableTextAccImpl;
	import spark.components.RichEditableText2;
	import spark.events.LinkElementFocusEvent;
	import spark.events.TextOperationEvent;
	
	use namespace mx_internal
	use namespace tlf_internal
	
	public class RichEditableText2AccImpl extends RichEditableTextAccImpl
	{
		
		//--------------------------------------------------------------------------
		//
		//  Class methods
		//
		//--------------------------------------------------------------------------
		
		/**
		 *  Enables accessibility in the RichEditableText class.
		 *
		 *  <p>This method is called by application startup code
		 *  that is autogenerated by the MXML compiler.
		 *  Afterwards, when instances of RichEditableText are initialized,
		 *  their <code>accessibilityImplementation</code> property
		 *  will be set to an instance of this class.</p>
		 *
		 *  @langversion 3.0
		 *  @playerversion Flash 10
		 *  @playerversion AIR 1.5
		 *  @productversion Flex 4
		 */
		public static function enableAccessibility():void
		{
			RichEditableText2.createAccessibilityImplementation = 
				createAccessibilityImplementation;
		}
		
		/**
		 *  @private
		 *  Creates a RichEditableText's AccessibilityImplementation object.
		 *  This method is called from UIComponent's
		 *  initializeAccessibility() method.
		 */
		mx_internal static function createAccessibilityImplementation(
			component:UIComponent):void
		{
			component.accessibilityImplementation =
				new RichEditableText2AccImpl(component);
		}
		
		//--------------------------------------------------------------------------
		//
		//  Constructor
		//
		//--------------------------------------------------------------------------
		
		/**
		 *  Constructor.
		 *
		 *  @param master The UIComponent instance that this AccImpl instance
		 *  is making accessible.
		 *
		 *  @langversion 3.0
		 *  @playerversion Flash 10
		 *  @playerversion AIR 1.5
		 *  @productversion Flex 4
		 */
		public function RichEditableText2AccImpl(master:UIComponent)
		{
			super(master);			
		}
		
		/**
		 *  @private
		 *  Array of events that we should listen for from the master component.
		 */
		override protected function get eventsToHandle():Array
		{
			return super.eventsToHandle.concat([ 
				FlexEvent.UPDATE_COMPLETE, FlexEvent.SELECTION_CHANGE, LinkElementFocusEvent.LINK_FOCUS_IN ]);
		}
		
		/**
		 *  @private
		 *  Gets the role for the component.
		 *
		 *  @param childID children of the component
		 */
		override public function get_accRole(childID:uint):uint
		{
			var richEditableText:RichEditableText2 = RichEditableText2(master);
			if (childID==0)
			{ 
				if (richEditableText.editable) return AccConst.ROLE_SYSTEM_TEXT;
				if (getChildIDArray().length==0) 
					return (richEditableText.linkElements.length==1) 
							? AccConst.ROLE_SYSTEM_LINK : AccConst.ROLE_SYSTEM_TEXT;
				return AccConst.ROLE_SYSTEM_GROUPING;
			}
			var readOnly:Boolean = !richEditableText.editable || !richEditableText.selectable;
			var flowElement:FlowElement = getItemAt(childID-1) as FlowElement;
			
			var linkElement:LinkElement = flowElement as LinkElement;
			if (linkElement)
				return AccConst.ROLE_SYSTEM_LINK;
			
			var graphicElement:GraphicElement = flowElement as GraphicElement;
			if (graphicElement)
				return AccConst.ROLE_SYSTEM_GRAPHIC;
			
			return (readOnly) ? AccConst.ROLE_SYSTEM_STATICTEXT : AccConst.ROLE_SYSTEM_TEXT;
		}
		
		/**
		 *  @private
		 *  IAccessible method for returning the state of the TextBase.
		 *  States are predefined for all the components in MSAA.
		 *  Values are assigned to each state.
		 *  Depending upon the TextBase being enabled,
		 *  a state is returned.
		 *
		 *  @param childID uint
		 *
		 *  @return State uint
		 */
		override public function get_accState(childID:uint):uint
		{
			var accState:uint = getState(childID);
			var childFocused:Boolean = (getChildIDArray().length==1 || RichEditableText2(master).caretIndex==childID-1);
			
			switch (get_accRole(childID))
			{
				case AccConst.ROLE_SYSTEM_LINK:
				{
					accState |= AccConst.STATE_SYSTEM_LINKED;
					if (childFocused)
						accState |= AccConst.STATE_SYSTEM_FOCUSED;
					break;
				}
				case AccConst.ROLE_SYSTEM_TEXT:
				case AccConst.ROLE_SYSTEM_STATICTEXT:
				{
					if (!RichEditableText2(master).selectable)
						accState &= ~AccConst.STATE_SYSTEM_FOCUSABLE;
					else if (childFocused)
						accState |= AccConst.STATE_SYSTEM_FOCUSED;
					if (!RichEditableText2(master).editable)
						accState |= AccConst.STATE_SYSTEM_READONLY;
					if (RichEditableText2(master).displayAsPassword)
						accState |= AccConst.STATE_SYSTEM_PROTECTED;
					break;
				}
				case AccConst.ROLE_SYSTEM_GROUPING:
				default:
				{
					accState &= ~AccConst.STATE_SYSTEM_FOCUSABLE;
					accState &= ~AccConst.STATE_SYSTEM_FOCUSED;
					break;
				}
			}
			
			if (!accLocation(childID))
				accState |= AccConst.STATE_SYSTEM_INVISIBLE;
			
			return accState;
		}
		
		/**
		 *  @private
		 *  IAccessible method for returning the childFocus of the RichEditableText2.
		 *
		 *  @param childID uint
		 *
		 *  @return focused childID.
		 */
		override public function get_accFocus():uint
		{
			var index:uint = RichEditableText2(master).caretIndex;
			
			return (getChildIDArray().length>1 && index >= 0) ? index + 1 : 0;
		}
		
		/**
		 *  @private
		 *  IAccessible method for returning the text value of the RichEditableText
		 *
		 *  @param childID uint
		 *
		 *  @return Value String
		 */
		override public function get_accValue(childID:uint):String
		{
			var flowElement:FlowElement;
			if (childID>0) flowElement = getItemAt(childID-1) as FlowElement;
			switch (get_accRole(childID))
			{
				case AccConst.ROLE_SYSTEM_LINK:
				{
					if (childID==0) flowElement = getItemAt(0) as FlowElement;
					return LinkElement(flowElement).href;
				}
				
				case AccConst.ROLE_SYSTEM_TEXT:
				{
					if (childID==0) flowElement = getItemAt(0) as FlowElement;
					if (!RichEditableText2(master).editable) 
						return null;
					var str:String = flowElement.getText();
					return (RichEditableText2(master).displayAsPassword) 
							? StringUtil.repeat("*", str.length) 
							: str;
				}
					
				case AccConst.ROLE_SYSTEM_STATICTEXT:
				default:
					return null;
			}
		}
		
		/**
		 *  @private
		 *  IAccessible method for returning the default action
		 *  of the LinkElement, which is Jump.
		 *
		 *  @param childID uint
		 *
		 *  @return DefaultAction String
		 */
		override public function get_accDefaultAction(childID:uint):String
		{
			switch (get_accRole(childID))
			{
				case AccConst.ROLE_SYSTEM_LINK:
				{
					return "Jump";
				}
				default:
					return null;
			}
		}
		
		
		override public function accDoDefaultAction(childID:uint):void
		{
			switch (get_accRole(childID))
			{
				case AccConst.ROLE_SYSTEM_LINK:
				{
					var index:uint = (childID==0) ? 0 : childID-1;
					RichEditableText2(master).triggerLinkElementClick(getItemAt(index) as LinkElement);
				}
			}
		}
		
		override public function accLocation(childID:uint):*
		{
			var index:uint = (childID==0) ? 0 : childID-1;
			var flowElement:FlowElement = getItemAt(index) as FlowElement;
			switch (get_accRole(childID))
			{
				case AccConst.ROLE_SYSTEM_LINK:
				{
					return RichEditableText2(master).getElementBounds(flowElement);
				}
					
				case AccConst.ROLE_SYSTEM_TEXT:
				case AccConst.ROLE_SYSTEM_STATICTEXT:
				case AccConst.ROLE_SYSTEM_GRAPHIC:
				{
					if (childID==0) return master;
					return RichEditableText2(master).getElementBounds(flowElement);
				}
				default:
					if (childID==0) return master;
					return null;
			}
		}
		
		//--------------------------------------------------------------------------
		//
		//  Overridden event handlers: AccImpl
		//
		//--------------------------------------------------------------------------
		private var timeoutID:uint;
		private var flagLinkFocused:Boolean = false;
		/**
		 *  @private
		 *  Override the generic event handler.
		 *  All AccImpl must implement this
		 *  to listen for events from its master component.
		 */
		override protected function eventHandler(event:Event):void
		{
			var index:int = RichEditableText2(master).caretIndex;
			var childID:int = (getChildIDArray().length==0) ? 0 : index + 1;
			
			switch (event.type)
			{
				case FlexEvent.UPDATE_COMPLETE:
				{
					if (flagLinkFocused)
					{
						Accessibility.updateProperties();
						Accessibility.sendEvent(master, childID, AccConst.EVENT_OBJECT_NAMECHANGE);
						Accessibility.sendEvent(master, childID, AccConst.EVENT_OBJECT_FOCUS);
						flagLinkFocused = false;
					}
					break;
				}
				case LinkElementFocusEvent.LINK_FOCUS_IN:
				{	
					if(!RichEditableText2(master).editable)
					{
						flagLinkFocused = true;
					}
					break;
				}
				default:
				{
					super.eventHandler(event);
				}
			}
		}
		
		
		
		/**
		 *  @private
		 *  method for returning the name of the RichEditableText
		 *  which is spoken out by the screen reader
		 *  If the text is read-only, the RichEditableText should return the text inside as the name of the RichEditableText.
		 *  The name in AccessibilityProperties is combined with the name
		 *  specified here.
		 *
		 *  @param childID uint
		 *
		 *  @return Name String
		 */
		override protected function getName(childID:uint):String
		{
			
			var index:uint = (childID==0) ? 0 : childID-1;
			var flowElement:FlowElement = getItemAt(index) as FlowElement;
			var str:String = flowElement.getText();
			str = (RichEditableText2(master).displayAsPassword) 
					? StringUtil.repeat("*", str.length) 
					: str;
			switch (get_accRole(childID))
			{
				case AccConst.ROLE_SYSTEM_LINK:
				case AccConst.ROLE_SYSTEM_STATICTEXT:
				{
					return str;
				}
					
				case AccConst.ROLE_SYSTEM_TEXT:
				{
					if (!RichEditableText2(master).editable)
						return str;
				}
				default:
					return null;
			}
		}
		
		/**
		 *  @private
		 *  Method to return an array of childIDs.
		 *
		 *  @return Array
		 */
		override public function getChildIDArray():Array
		{
			var richEditableText:RichEditableText2 = RichEditableText2(master);
			var n:int = 0;
			if(!richEditableText.editable 
				&& richEditableText.accessibleElements 
				&& richEditableText.accessibleElements.length>1)
				n = richEditableText.accessibleElements.length;
			
			return createChildIDArray(n);
		}
		
		//--------------------------------------------------------------------------
		//
		//  Methods
		//
		//--------------------------------------------------------------------------
		
		/**
		 *  @private
		 */
		private function getItemAt(index:int):Object
		{
			if (RichEditableText2(master).accessibleElements)
				return RichEditableText2(master).accessibleElements[index];
			else
				return master;
		}
		
		/**
		 *  @private
		 */
		private function focusInHandler(event:Event):void
		{
			var childID:uint = (RichEditableText2(master).caretIndex != -1) ? RichEditableText2(master).caretIndex + 1 : 0;
			Accessibility.sendEvent(master, childID, AccConst.EVENT_OBJECT_FOCUS);
		}
	}
}